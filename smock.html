<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <!--
Definitions (code cleanup still pending to use these consistently)
- Unit (block/chunk represented as 1 and 16)
- Vec
  - Can be in block or chunk units
  - Add an indicator of which and error if combined illegally?
- Rect
  - "from" = northwest corner, "to" = southeast corner
  - Both must use same units
  - from and to are both *inclusive*
  - "cols", "rows" mean (to - from + 1) in each axis
    - rename as size-x, size-z ?
- Orientation (change face-north to orient-north etc)
- Orbit (clockwise/anti as 1/-1)
  - Add orbit.Clockwise and orbit.Anticlockwise a la orientations.North etc
- Turn (left/right as -1/1)
  - Add turn.Left and turn.Right a la orientations.North
- Face (ahead/behind as 1/-1)
  - Add face.Ahead and face.Behind a la orientations.North etc
- Progression (forward/reverse as 1/-1)
  - Add progression.Forward and progression.Reverse
- Point
  - A vec in block units. Integer coordinates represent the center of blocks.
  - Rename pointToId and pointToHash as vecTo... because they aren't point-specific
- Chunk
  - A vec in chunk units. Coordinates must be integers. Represents a 16x16 block rect with from=chunk.from * 16
  - Rendered as a div class="chunk" with id=[layer]_[vecToId(chunk)]
- Grid
  - The rect representing the entire area to be rendered.
  - Replace global to/from with gridRect
- Strip
  - A rect with one of its dimensions equal to 1 (from.x == to.x || from.z == to.z). Tagged as "across" or "down" depending on which one applies.
  - Possibly if both dimensions are 1 tag it as 'single'? Grid gradient background can be avoided in that case.
- Segment
  - A strip representing part of the path-walk.
  - Data structure as is now
- Fragment
  - A part of a segment cut to the part that fits within a single chunk. Uses the same data structure as a segment itself.
- Ring
  - Center, inner boundary radius, outer boundary radius
  - Also refers to blocks between the two radii
- Edge
  - Inside/Outside/Straddle (-1 / 0 / 1)
- Boundary
  - Inner/Outer/Middle (represented by radii rather than ints)
- Path
  - An edge of a boundary
  - Represented by edge and radius
  - Replaces "highlight function"


            TO DO:
            - Chunks
                - Give grid chunks .grid-chunk class and path chunks .path-chunk, and both .chunk
                - Make path chunks position the same way grid chunks do so their element boundaries are right
                - Fix size thresholds to be bigger in chrome because it doesn't suck so much at 3d (but still not unlimited)
            - Put coords and face and a mini-compass next to crosshairs instead of up top
                    (with bg color set to sky gradient)
            - Implement walk step flash the new way
            - Implement hover and click-to-set-point
            - Fix positioning of "Facing" in Chrome
            - Coordinate labels around perimeter positioned outside grid and have their own transforms to keep them upright during spins (and possibly even flat during 3d tilt)
            - Clean up code and remove unused stuff
            - Eliminate jQuery dependency

            - Changes to loadFromHash:
                  - No longer treat part of the url being missing/invalid as 'leave unchanged', but rather as 'reset to default'
                  - If the circle parameters aren't changed it knows not to rerender
                  - If the path choice is unchanged it knows not to refresh the path
                  - If we're already in walk mode it knows not to exit and re-enter it
                  - If the walk choices (fwd/rev/pause, clockwise/anti, ahead/behind, 3d, speed) are all that's changed then it simply changes the form controls' state and calls triggerWalkStep to pick up the changes
                  - Change url representation so that in unpaused states the step no isn't part of the url; in paused states the step no replaces 'paused' in the url
                  - If we are moving to a (paused) stepNo that's within 2 of current stepNo then it sets pendingSteps; if further away than that then it zooms straight to the appropriate point
                  - Use speed10 for pendingSteps regardless of speed slider
                  - Decrement pendingSteps at end of animation step, eg
                    if (playMode == paused) pendingSteps -= Math.sign(pendingSteps)
                    - Allows easy detection of which direction we're moving even if we're doing so as a pendingStep, which lets us fix the animation direction for the fades

            - Walk mode:
                - Fix step number, it does weird stuff when flipping directions
                - Walk button can be a styled checkbox
                - Disable form controls in walk mode
                - Animate rotation and zoom into walk mode
                - Animate out of walk mode
                - Figure out scrolling up vs down correctly for coordinates
                    - It's more or less 'go downwards if looking backward or playing in reverse but not both' but detecting the 'playing in reverse' isn't easy with singlestepping
                    - Directions need to go upwards if you're playing in reverse
                - Click directions to get full list
                - Animate into and out of 3d mode
            - Use mousemove events and an overlay square to show coords so that individual squares don't need to be individual divs
            - Add extra row/col with coords on left/right/top/bottom (outermost values and multiples of 5, small font, text-align center on top/bottom and left/right on right/left, overflow visible)
                - Consider making those slide into an overlay position during walk mode so they stay in view and rotate to stay upright
            - Prettify controls
                - (x) next to center coords to make it auto, visible only if not autocenter
                - (x) next to each point to remove it, except the last empty one
                - [Clear All] button under list of points (enabled if any points exist)
                - Make radio lists appear on focus as well as hover
                - Consider moving controls to top right instead of top left
                - Pressing ',' in an X coord box jumps to corresponding Z
                - Pressing Enter in an X or Z jumps to next box
                - Make sure tab works with all controls
                - Try making a graphical representation of path and point size tuning
            - Fix autocenter algorithm
                - If only one point, use it. If zero points, use 0,0.
                - Take two furthest points apart, take midpoint, set radius at half their distance apart
                - Iterate as follows:
                - Classify all points as inside or outside the current circle.
                - If all inside, we're done.
                - Take furthest point from current center and use existing algorithm to grow circle to include it.
            - Theming (eventually)
                - css file smock-theme-xxx.css
                - .smock-theme-xxx {
                    --theme-name: 'My theme';
                  }
                  #smock.smock-theme-xxx {
                    --ui-bg-colour: ... etc;
                  }
            - Config (eventually)
                - JS file smock-config.js
                - var smockConfig = {
                    themes: ['default', 'nether', ...],
                    chunkSize: 16,
                    walkStartSpeed: 7,
                    walkStartClockwise: true,
                    walkStartLookingBehind: true,
                    walkStartIn3D: true,
                  };
        -->
        <title>Stuart's M---craft Overcomplicated Circle Kit</title>
        <style type="text/css">
            body {
                --block-border: 4px;
                --block-size: calc(var(--block-border) * 10);

                --scale-normal: 0.25;
                --scale-walk: 1;
                --scale-walk3d: 2;

                --gridline-colour: black;
                --outside-colour: #686;
                --ring-colour: #333;
                --inside-colour: #af8;
                --path-colour: blue;
                --path-connect-colour: purple;
                --flash-colour: white;
                --crosshairs-colour: green;
                --point-border-colour: red;
                --point-fill-colour: rgba(255, 0, 0, 0.3);
                --centre-border-colour: black;
                --centre-fill-colour: green;
                --inner-circle-colour: magenta;
                --mid-circle-colour: purple;
                --outer-circle-colour: blue;
                --sky-gradient: linear-gradient(to left, #f8bd17 30%, #b6ebf5, #83e5f7, #0c2174 70%);
                --ui-bg-gradient: linear-gradient(to bottom, black, #333);
                --ui-panel-bg-gradient: linear-gradient(to right, #444, #666);
                --ui-text-colour: #ccc;
                --ui-sky-text-colour: black;
                --ui-frame-colour: #333;
                --ui-button-bg-colour: var(--ui-frame-colour);
                --ui-button-selected-bg-colour: var(--path-colour);
                --ui-button-hover-bg-colour: var(--path-connect-colour);
                --ui-button-fg-colour: var(--ui-text-colour);
                --ui-button-selected-fg-colour: white;
            }

            /* Speeds 1-10 consisting of 1=4s, 2=3.5s, 3=3s, 4=2.5s, 5=2s, 6=1.5s, 7=1.25s, 8=1s, 9=0.75s, 10=0.5s */
            /* Halfstep really ought to be calc'd but apparently that's not supported */
            .viewport.speed1 { --steptime: 4s; --halfstep: 2s; }
            .viewport.speed2 { --steptime: 3.5s; --halfstep: 1.75s; }
            .viewport.speed3 { --steptime: 3s; --halfstep: 1.5s; }
            .viewport.speed4 { --steptime: 2.5s; --halfstep: 1.25s; }
            .viewport.speed5 { --steptime: 2s; --halfstep: 1s; }
            .viewport.speed6 { --steptime: 1.5s; --halfstep: 0.75s; }
            .viewport.speed7 { --steptime: 1.25s; --halfstep: 0.625s; }
            .viewport.speed8 { --steptime: 1s; --halfstep: 0.5s; }
            .viewport.speed9 { --steptime: 0.75s; --halfstep: 0.375s; }
            .viewport.speed10 { --steptime: 0.5s; --halfstep: 0.25s; }

            /* We don't want the flash speed to slow all the way down at slower step speeds */
            .viewport.speed1, .viewport.speed3 { --flashtime: 1s; }
            .viewport.speed2 { --flashtime: 1.2s; }
            .viewport.speed4, .viewport.speed5, .viewport.speed6 { --flashtime: var(--halfstep); }
            .viewport { --flashtime: var(--steptime); }

            body {
                background: var(--ui-bg-gradient);
                background-size: auto 250px;
            }

            input[type='number'] {
                width: 5em;
            }

            .centerlabel {
                display: none;
            }
            .autocenter .centerlabel {
                display: inline;
            }

            .column {
                background: var(--ui-panel-bg-gradient);
                padding: 10px;
                color: var(--ui-text-colour);
                float: left;
                height: 210px;
                width: 18em;
                border-radius: 5px;
                margin-right: 5px;
            }
            .pointscol {
                overflow-y: auto;
                width: 12em;
            }

            .radiolist {
                overflow: visible;
                vertical-align: top;
                margin: 4px 0;
            }
            .radiolist:hover .itemwrapper {
                z-index: 1;
            }
            .radiolist .radiolabel {
                display: inline-block;
                padding: 5px 0;
                vertical-align: top;
            }
            .radiolist .itemwrapper {
                vertical-align: top;
                top: 0px;
                position: relative;
                display: inline-block;
                height: 0px;
                overflow: visible;
            }
            .radiolist .items {
                position: absolute;
                white-space: nowrap;
                padding: 5px;
                padding-right: 20px;
                border-radius: 3px;
                background-color: var(--ui-button-bg-colour);
            }
            .radiolist label {
                display: block;
                height: 0px;
                overflow: hidden;
            }
            .radiolist label.currentradio, .radiolist:hover label {
                height: auto;
            }
            #walk {
                float: right;
            }

            span.block, span.stack {
                display: inline-block;
                border: 1px solid var(--gridline-colour);
                width: 10px;
                height: 10px;
                margin-right: 1px;
                margin-left: 2px;
                background: var(--block-colour);
                --stack-colour: var(--block-colour);
            }
            span.stack {
                position: relative;
                top: -2px;
                left: -2px;
                box-shadow: 2px 2px 0px -1px var(--stack-colour),
                     2px 2px var(--gridline-colour),
                     4px 4px 0px -1px var(--block-colour),
                     4px 4px var(--gridline-colour);
                margin-right: 3px;
            }
            span.block.path-block, span.stack.path-block {
                background: linear-gradient(45deg, var(--path-colour), var(--path-colour) 50%, var(--path-connect-colour) 50%, var(--path-connect-colour));
                --block-colour: var(--path-colour);
                --stack-colour: var(--path-connect-colour);
            }

            div.progress {
                background: var(--ui-panel-bg-gradient);
                background-position: left;
                background-repeat: no-repeat;
            }

            .backdrop {
                width: calc(var(--cols) * var(--block-size) + var(--block-border));
                height: calc(var(--rows) * var(--block-size) + var(--block-border));
            }
            .grid-area {
                width: calc(var(--cols) * var(--block-size) + var(--block-border));
                height: calc(var(--rows) * var(--block-size) + var(--block-border));
                position: relative;
            }
            .crosshair-layer {
                display: none;
            }
            .viewport.walk-mode .crosshair-layer {
                display: block;
            }

            .crosshair {
                border: var(--block-border) solid var(--crosshairs-colour);
                position: absolute;
                outline: 1px solid transparent;
                box-shadow: 0 0 calc(var(--block-border) * 2) black;
            }
            .crosshair.across {
                height: calc(var(--block-size) + var(--block-border));
                top: calc(var(--block-size) * (var(--rows) - 1) / 2 - var(--block-border));

                width: calc(var(--block-size) * 50);
                left: calc(var(--block-size) * (var(--cols) - 50) / 2);
            }
            .crosshair.down {
                width: calc(var(--block-size) + var(--block-border));
                left: calc(var(--block-size) * (var(--cols) - 1) / 2 - var(--block-border));

                height: calc(var(--block-size) * 20);
                top: calc(var(--block-size) * (var(--rows) - 20) / 2);
            }

            .blocks {
                display: block;
                position: absolute;
                left: calc((var(--x) - var(--fromx)) * var(--block-size) - var(--block-border));
                top: calc((var(--z) - var(--fromz)) * var(--block-size) - var(--block-border));
                width: calc(var(--cols) * var(--block-size) - var(--block-border));
                height: calc(var(--rows) * var(--block-size) - var(--block-border));
                border: var(--block-border) solid var(--gridline-colour);
                background-color: var(--block-colour);
                outline: 1px solid transparent;
            }
            .blocks.across {
                background-image: repeating-linear-gradient(to right,
                    var(--block-colour),
                    var(--block-colour) calc(var(--block-size) - var(--block-border)),
                    var(--gridline-colour) calc(var(--block-size) - var(--block-border)),
                    var(--gridline-colour) var(--block-size));
                --rows: 1;
            }
            .blocks.down {
                background-image: repeating-linear-gradient(to bottom,
                    var(--block-colour),
                    var(--block-colour) calc(var(--block-size) - var(--block-border)),
                    var(--gridline-colour) calc(var(--block-size) - var(--block-border)),
                    var(--gridline-colour) var(--block-size));
                --cols: 1;
            }
            .blocks.bare {
                left: calc((var(--x) - var(--fromx)) * var(--block-size) + var(--block-border));
                top: calc((var(--z) - var(--fromz)) * var(--block-size) + var(--block-border));
                border: none;
            }
            .blocks.down.trans {
                --block-colour: rgba(0,0,0,0);
                --rows: inherit;
                --cols: inherit;
            }
            .blocks.outside {
                --block-colour: var(--outside-colour);
            }
            .blocks.ring, span.ring-block {
                --block-colour: var(--ring-colour);
            }
            .blocks.inside, span.interior-block {
                --block-colour: var(--inside-colour);
            }
            .blocks.highlight, span.highlight-block {
                --block-colour: var(--path-colour);
            }
            .blocks.connect, span.connect-block {
                --block-colour: var(--path-connect-colour);
                --rows: 1;
                --cols: 1;
            }

            .viewport.walk-mode #loctable {
                transform: translate(calc((var(--fromx) + var(--cols) * 0.5 - var(--point-x) - 0.5) * var(--block-size) + var(--block-border)),
                                     calc((var(--fromz) + var(--rows) * 0.5 - var(--point-z) - 0.5) * var(--block-size) + var(--block-border)));
            }

            @keyframes appear {
                from { opacity: 0; }
            }

            @keyframes flash {
                50% { background-color: var(--flash-colour); }
            }

            .blocks.bare.walkpoint {
                animation-name: flash;
                animation-duration: var(--flashtime);
                animation-iteration-count: infinite;
            }

            .path-layer {
                position: absolute;
                top: var(--block-border);
                left: var(--block-border);
                bottom: 0px;
                right: 0px;
            }

            .chunk {
                --chunk-x: var(--x);
                --chunk-z: var(--z);
            }
            .chunk .blocks {
                --fromx: var(--chunk-x);
                --fromz: var(--chunk-z);
            }
            .chunk, .blocks.highlight, .blocks.connect {
                animation-name: appear;
                animation-duration: 1s;
                animation-fill-mode: both;
            }

            @keyframes circlein {
                from {
                    transform: scale(0);
                }

                60% {
                    border-width: var(--block-border);
                    margin-left: 0px;
                    margin-top: 0px;
                }

                80% {
                    border-width: calc(var(--block-border) * 3);
                    margin-left: calc(var(--block-border) * -2);
                    margin-top: calc(var(--block-border) * -2);
                    transform: scale(1.02);
                }
            }

            .circle {
                position: absolute;
                pointer-events: none;
                top: calc((var(--z) - var(--fromz) - var(--radius) + 0.5) * var(--block-size) - var(--block-border));
                left: calc((var(--x) - var(--fromx) - var(--radius) + 0.5) * var(--block-size) - var(--block-border));
                padding: calc(var(--radius) * var(--block-size) - var(--block-border) / 2);
                border: var(--block-border) solid var(--gridline-colour);
                border-radius: 50%;
                animation-name: circlein;
                animation-duration: 1s;
                box-shadow: 0 0 calc(var(--block-border) * 2) black, inset 0 0 calc(var(--block-border) * 2) black;
            }
            .circle.size-huge,
            .viewport.walk-mode .circle.size-large,
            .viewport.walk-mode.view3d .circle.size-biggish {
                display: none;
            }

            .circle.center {
                border-color: var(--centre-border-colour);
                background-color: var(--centre-fill-colour);
            }

            .circle.point {
                border-color: var(--point-border-colour);
                background-color: var(--point-fill-colour);
            }

            .circle.inner {
                border-color: var(--inner-circle-colour);
            }

            .circle.mid {
                border-color: var(--mid-circle-colour);
            }

            .circle.outer {
                border-color: var(--outer-circle-colour);
            }

            .viewport {
                overflow: hidden;
                position: fixed;
                top: 250px;
                left: 0px;
                right: 0px;
                bottom: 0px;
            }
            .viewport .sky {
                position: absolute;
                left: -100%;
                top: -100%;
                right: -100%;
                bottom: -100%;
                padding: 100%;
                background: var(--sky-gradient);
                background-size: 140% 140%;
                background-position: center;
            }
            .viewport.face-north .sky {
                transform: rotate(0deg);
            }
            @keyframes bgnorthleft { from { transform: rotate(-90deg); } }
            @keyframes bgnorthright { from { transform: rotate(90deg); } }
            @keyframes bgnorth180 { from { transform: rotate(180deg); } }
            .viewport.face-north.turn-left .sky {
                animation-name: bgnorthleft;
            }
            .viewport.face-north.turn-right .sky {
                animation-name: bgnorthright;
            }
            .viewport.face-north.turn-180 div.sky {
                animation-name: bgnorth180;
            }

            .viewport.face-east .sky {
                transform: rotate(-90deg);
            }
            @keyframes bgeastleft { from { transform: rotate(-180deg); } }
            @keyframes bgeastright { from { transform: rotate(0deg); } }
            @keyframes bgeast180 { from { transform: rotate(90deg); } }
            .viewport.face-east.turn-left .sky {
                animation-name: bgeastleft;
            }
            .viewport.face-east.turn-right .sky {
                animation-name: bgeastright;
            }
            .viewport.face-east.turn-180 div.sky {
                animation-name: bgeast180;
            }

            .viewport.face-south .sky {
                transform: rotate(180deg);
            }
            @keyframes bgsouthleft { from { transform: rotate(90deg); } }
            @keyframes bgsouthright { from { transform: rotate(270deg); } }
            @keyframes bgsouth180 { from { transform: rotate(360deg); } }
            .viewport.face-south.turn-left .sky {
                animation-name: bgsouthleft;
            }
            .viewport.face-south.turn-right .sky {
                animation-name: bgsouthright;
            }
            .viewport.face-south.turn-180 div.sky {
                animation-name: bgsouth180;
            }

            .viewport.face-west .sky {
                transform: rotate(90deg);
            }
            @keyframes bgwestleft { from { transform: rotate(0deg); } }
            @keyframes bgwestright { from { transform: rotate(180deg); } }
            @keyframes bgwest180 { from { transform: rotate(270deg); } }
            .viewport.face-west.turn-left .sky {
                animation-name: bgwestleft;
            }
            .viewport.face-west.turn-right .sky {
                animation-name: bgwestright;
            }
            .viewport.face-west.turn-180 div.sky {
                animation-name: bgwest180;
            }

            .table {
                position: absolute;
                top: 0px;
                bottom: 0px;
                left: 0px;
                right: 0px;
            }

            @keyframes turnleft {
                from {
                    transform: rotate(-90deg);
                }
            }
            @keyframes turnright {
                from {
                    transform: rotate(90deg);
                }
            }
            @keyframes turn180 {
                from {
                    transform: rotate(180deg);
                }
                to {
                    transform: rotate(0);
                }
            }

            @keyframes movenorth {
                from {
                    transform: translate(0, calc(var(--block-size) * -1)); /* Variable */
                }
            }
            @keyframes moveeast {
                from {
                    transform: translate(var(--block-size), 0); /* Variable */
                }
            }
            @keyframes movesouth {
                from {
                    transform: translate(0, var(--block-size)); /* Variable */
                }
            }
            @keyframes movewest {
                from {
                    transform: translate(calc(var(--block-size) * -1), 0); /* Variable */
                }
            }

            .face-north #facetable {
                transform: rotate(0);
            }
            .face-east #facetable {
                transform: rotate(-90deg);
            }
            .face-south #facetable {
                transform: rotate(180deg);
            }
            .face-west #facetable {
                transform: rotate(90deg);
            }

            .turn-left #turntable {
                animation-name: turnleft;
            }
            .turn-right #turntable {
                animation-name: turnright;
            }
            .viewport.turn-180 #turntable {
                animation-name: turn180;
            }
            .move-north #movetable {
                animation-name: movenorth;
            }
            .move-east #movetable {
                animation-name: moveeast;
            }
            .move-south #movetable {
                animation-name: movesouth;
            }
            .move-west #movetable {
                animation-name: movewest;
            }
            .viewport .window {
                animation-duration: 1s;
                position: absolute;
                left: 0;
                top: 0;
                min-width: calc(100% - 100px);
                min-height: calc(100% - 100px);
                padding: 50px;
                overflow: auto;
            }

            @keyframes windowwalkin {
                from { top: 0; }
            }
            @keyframes windowwalkout {
                from {
                    top: 77px;
                    width: calc(100% - 100px);
                    height: calc(100% - 177px);
                }
            }

            .viewport.end-walk .window {
                animation-name: windowwalkout;
            }

            .viewport.walk-mode .window {
                animation-name: windowwalkin;
                top: 77px;
                width: calc(100% - 100px);
                height: calc(100% - 177px);
                overflow: hidden;
            }

            .viewport .walk-info {
                animation-duration: 1s;
                height: 75px;
                position: absolute;
                top: -77px;
                width: 100%;
                border-bottom: 2px solid var(--ui-frame-colour);
                overflow: hidden;
            }
            @keyframes walkinfoin {
                from { top: -77px; }
            }
            @keyframes walkinfoout {
                from { top: 0px; }
            }
            .viewport.end-walk .walk-info {
                animation-name: walkinfoout;
            }
            .viewport.walk-mode .walk-info {
                top: 0px;
                animation-name: walkinfoin;
            }

            .walk-toolbar {
                vertical-align: top;
                background-color: var(--ui-frame-colour);
                padding-bottom: 1px;
            }
            .walk-toolbar-grp {
                padding-left: 5px;
                padding-right: 5px;
            }
            #step-rev {
                transform: scaleX(-1);
            }
            .tool-button:not(.big) {
                font-size: larger;
            }
            .tool-button input {
                display: none;
            }
            .tool-button input:checked + label {
                background: var(--ui-button-selected-bg-colour);
                color: var(--ui-button-selected-fg-colour);
                width: 20px;
                display: inline-block;
                font-weight: bold;
            }
            .tool-button {
                border: 1px solid var(--ui-frame-colour);
                color: var(--ui-button-fg-colour);
                background-color: var(--ui-button-bg-colour);
                width: 20px;
                display: inline-block;
                cursor: default;
                text-align: center;
                vertical-align: top;
                line-height: 25px;
                font-family: 'Segoe UI Symbol';
            }
            .tool-button:hover, .tool-button:hover input[type='checkbox']:checked + label {
                background-color: var(--ui-button-hover-bg-colour);
            }
            .tool-slider input {
                vertical-align: top;
                width: 100px;
                height: 20px;
            }
            .tool-slider input::-moz-range-thumb {
                background-color: var(--ui-button-selected-bg-colour);
            }
            .tool-slider input::-moz-range-thumb:hover {
                background-color: var(--ui-button-hover-bg-colour);
            }
            #exit-walk {
                float: right;
            }

            .viewport .walk-info form, .viewport .walk-info .walk-directionbar, .viewport .walk-info .walk-location {
                display: block;
                width: 35em;
                margin-left: auto;
                margin-right: auto;
                overflow: hidden;
                border-left: 2px solid var(--ui-frame-colour);
                border-right: 2px solid var(--ui-frame-colour);
                position: relative;
            }
            .walk-directionbar {
                height: 23px;
                border-bottom: 2px solid var(--ui-frame-colour);
            }

            @keyframes upfading {
                from { top: 25px; }
            }
            @keyframes downfading {
                from { top: -25px; }
            }
            @keyframes fadeprev {
                from { top: 0px; }
            }

            .fade-box {
                position: relative;
                display: inline-block;
            }
            .fade {
                position: absolute;
            }
            .viewport .fade-box.fading .fade {
                animation-fill-mode: both;
                animation-timing-function: ease-in;
            }
            .viewport .fade-box.fading .fade.current {
                top: 0px;
                animation-name: upfading;
            }
            .viewport .fade-box .fade.previous {
                visibility: hidden;
            }
            .viewport .fade-box.fading .fade.previous {
                top: -25px;
                animation-name: fadeprev;
                visibility: visible;
            }

            .viewport.turn-left .walk-face.fade-box.fading .fade.current {
                animation-name: downfading;
            } 
            .viewport.turn-left .walk-face.fade-box.fading .fade.previous {
                top: 25px;
            }

            .walk-info span, .walk-info strong {
                display: inline-block;
            }
            .viewport.walk-info > span {
                height: 23px;
                border-left: 1px solid var(--ui-frame-colour);
                border-right: 1px solid var(--ui-frame-colour);
                padding: 0px 5px;
            }
            .walk-label {
                height: 21px;
                background-color: var(--ui-frame-colour);
                color: var(--ui-text-colour);
                padding: 1px 5px;
            }
            .walk-direction {
                width: 34em;
                height: 25px;
                color: var(--ui-sky-text-colour);
            }
            .walk-direction .fade {
                width: 34em;
                text-align: center;
            }
            .walk-coord {
                width: calc(6em + 10px);
                color: var(--ui-sky-text-colour);
            }
            .walk-coord .walk-label {
                width: 1em;
            }
            .walk-coord .fade {
                width: 5em;
                text-align: center;
            }
            .walk-face .walk-label {
                width: 5em;
            }
            .walk-face {
                color: var(--ui-sky-text-colour);
            }
            .walk-face .fade {
                width: 14em;
                padding-left: 5px;
            }
            .viewport .backdrop, .viewport #backtable {
                position: absolute;
            }
            .viewport:not(.walk-mode) #backtable {
                padding: 20px;
            }
            .viewport:not(.walk-mode) .backdrop {
                transform: translate(-50%, -50%) scale(var(--scale-normal)) translate(50%, 50%);
            }
            .viewport.walk-mode .backdrop {
                transform: translate(-50%, -50%) scale(var(--scale-walk));
            }
            .viewport.walk-mode #backtable {
                transform: translate(50%, 25%);
            }

            .viewport.walk-mode .chunk, .viewport.walk-mode .path-blocks-layer { display: none; }
            .viewport.walk-mode .chunk.shown, .viewport.walk-mode .path-blocks-layer.shown { display: block; }

            .viewport.walk-mode.view3d * {
                transform-style: preserve-3d;
            }
            .viewport.walk-mode.view3d .backdrop {
                transform: translate(-50%, -50%) scale(var(--scale-walk3d));
            }
            .viewport.walk-mode.view3d #backtable {
                perspective: 500px;
                perspective-origin: 0% 50%;
            }
            .viewport.walk-mode.view3d #tilttable {
                transform: translateZ(calc(-1 * var(--block-size))) rotateX(40deg); /* Variable */
            }
            .viewport.walk-mode.view3d.turn-right #tilttable, .viewport.walk-mode.view3d.turn-left #tilttable, .viewport.walk-mode.view3d.turn-180 #tilttable {
                animation-name: glance-down;
            }
            @keyframes bounce3d {
                50% {
                    background-color: var(--flash-colour);
                    transform: translateZ(calc(2 * var(--block-border))); /* Variable */
                }
            }
            .viewport.view3d .blocks.bare.walkpoint {
                animation-name: bounce3d;
            }
            .viewport.view3d .path-blocks-layer,
            .viewport.view3d .circle-layer,
            .viewport.view3d .crosshair-layer {
                transform: translateZ(var(--block-border));
            }

            @keyframes glance-down {
                30% {
                    transform: translate3d(0, 0, calc(-1 * var(--block-size))) rotateX(30deg) translate3d(0, calc(0.5 * var(--block-size)), 0); /* Variable x2 */
                }
                70% {
                    transform: translate3d(0, 0, calc(-1 * var(--block-size))) rotateX(30deg) translate3d(0, calc(0.5 * var(--block-size)), 0); /* Variable x2 */
                }
            }

            .viewport .walkanim { animation-duration: var(--steptime); }
            .viewport .fade { animation-duration: var(--halfstep); } /* Fading is half the time of everything else */
            .viewport .walk-direction .fade { animation-delay: var(--halfstep); }

        </style>
        <script src="https://code.jquery.com/jquery-1.12.3.min.js" integrity="sha256-aaODHAgvwQW1bFOGXMeX+pC4PZIPsvn2h1sArYOhgXQ=" crossorigin="anonymous"></script>
        <script>
            var pointCounter = 0;
            var center = { x: 0, z: 0 };
            var inner = 0;
            var outer = 0.5;
            var from = { x: 0, z: 0 };
            var to = { x: 0, z: 0 };
            var shownChunkRect;

            // Firefox in particular has difficulties with really big circle divs when zoomed and 3d'd so we hide them if they get too big.
            // Chrome can handle larger sizes (FIXME: figure out sensible thresholds for chrome)
            const sizeThresholds = Object.freeze({
                huge: 128,
                large: 32,
                biggish: 16,
            });

            $(function () {
                loadFromHash();
                $('#mainForm').on('change', refreshForm);
                $('.viewport').on('animationend', walkStepAnimationEnd);
                //$('#circleHolder').on('click', pointClick);
                $(window).on('hashchange', loadFromHash);
//                $('#directions').click(function () { $('#directions').text(getFullDirections(1, getCurrentHighlightFunction())) });

                $('#walk').on('click', startWalk);
                $('.tool-button.trigger').click(triggerWalkStep);
                $('.tool-button:not(.trigger)').click(setHash);
                $('#step-rev').click(function () { walkSingleStep(-1); });
                $('#step-fwd').click(function () { walkSingleStep(1); });
                $('#exit-walk').click(endWalk);
            });

            function refreshForm(evt) {

                $('.currentradio').removeClass('currentradio');
                $('.radiolist input:checked').parent('label').addClass('currentradio');

                if (evt && evt.originalEvent.target.getAttribute('name') == 'highlight') {
                    refreshPath();
                    setHash();
                    return;
                }

                if ($('#pointsList pointrow').length == 0) addPoint();

                var radius = document.getElementById('correction_radius');
                setBoolAttr(radius, 'disabled',
                  document.forms[0]['correction'].value != 'custom');
                radius.valueAsNumber = getCorrectionRadius();
                setCoordsRequired('center');
                refreshPointsList();
                $('#validate').click();
                if (document.forms[0].checkValidity()) buildCircle();
                endWalk();
            }
            function refreshPointsList() {
                var lastId = $('#pointsList .pointrow').last().attr('id');
                $('#pointsList .pointrow').each(function () {
                    var pointId = $(this).attr('id');
                    setCoordsRequired(pointId);
                    if (pointId == lastId) {
                        if ($('#' + pointId + '_x').val() != '' &&
                            $('#' + pointId + '_z').val() != '') {
                            addPoint();
                        }
                    } else {
                        if ($('#' + pointId + '_x').val() == '' &&
                            $('#' + pointId + '_z').val() == '') {
                            $(this).remove();
                        }
                    }
                });
            }
            function addPoint() {
                pointCounter++;
                var tmpl = document.getElementById('pointTemplate');
                var row = document.importNode(tmpl.content, true);
                row.querySelector('.pointrow').setAttribute('id', 'point' + pointCounter);
                row.querySelector('.pointx').setAttribute('id', 'point' + pointCounter + '_x');
                row.querySelector('.pointz').setAttribute('id', 'point' + pointCounter + '_z');
                document.getElementById('pointsList').appendChild(row);
            }
            function getPoints() {
                return $('#pointsList .pointrow').map(function () {
                    var pointId = $(this).attr('id');
                    var xElem = document.getElementById(pointId + '_x');
                    var zElem = document.getElementById(pointId + '_z');

                    if (xElem.value == '' || zElem.value == '') {
                        return null;
                    }
                    return { x: xElem.valueAsNumber, z: zElem.valueAsNumber };
                }).get();
            }
            function pointClick(evt) {
                var cell = evt.originalEvent.target;
                if (!$(cell).hasClass('gb')) return;
                var point = cellCoords(cell);
                if (evt.originalEvent.shiftKey) {
                    document.getElementById('center_x').valueAsNumber = point.x;
                    document.getElementById('center_z').valueAsNumber = point.z;
                } else {
                    var found = false;
                    elemsDo('#pointsList .pointrow', function(row) {
                        var x = elemBy('.pointx', row).valueAsNumber;
                        var z = elemBy('.pointz', row).valueAsNumber;
                        if (x == point.x && z == point.z) {
                            elem.remove();
                            found = true;
                            return false;
                        }
                    });

                    if (!found) {
                        addPoint();
                        elemById('point' + pointCounter + '_x').valueAsNumber = point.x;
                        elemById('point' + pointCounter + '_z').valueAsNumber = point.z;
                    }
                }
                refreshForm();
            }
            function setCoordsRequired(nameBase) {
                var xElem = elemById(nameBase + '_x');
                var zElem = elemById(nameBase + '_z');
                elemDo(xElem, elemSetAttr('required', zElem.value != ''));
                elemDo(zElem, elemSetAttr('required', xElem.value != ''));
            }
            function setBoolAttr(elem, attr, value) {
                if (value) {
                    $(elem).attr(attr, attr);
                } else {
                    $(elem).removeAttr(attr);
                }
            }
            function getCorrectionRadius() {
                switch (document.forms[0]['correction'].value) {
                    case 'point': return 0;
                    case 'inside': return 0.5;
                    case 'area': return 1.0 / Math.sqrt(Math.PI);
                    case 'outside': return Math.SQRT1_2;
                    case 'custom': return document.getElementById('correction_radius').valueAsNumber;
                }
                return 0;
            }
            function vecEqual(a, b) {
                return a.x == b.x && a.z == b.z;
            }
            function vecAdd(a, b) {
                return { x: a.x + b.x, z: a.z + b.z };
            }
            function vecSub(a, b) {
                return { x: a.x - b.x, z: a.z - b.z };
            }
            function vecDot(a, b) {
                return a.x * b.x + a.z * b.z;
            }
            function vecMul(v, scalar) {
                return { x: v.x * scalar, z: v.z * scalar };
            }
            function vecDiv(v, scalar) {
                return { x: v.x / scalar, z: v.z / scalar };
            }
            function vecSquared(v) {
                return vecDot(v, v);
            }
            function vecMod(v) {
                return Math.sqrt(vecSquared(v));
            }
            function getDistance(pt1, pt2) {
                return vecMod(vecSub(pt1, pt2));
            }
            function vecStr(v) {
                return 'X' + v.x + ', Z' + v.z;
            }
            function pointToId(point) {
                return 'x' + point.x + 'z' + point.z;
            }
            function idToPoint(id) {
                var zstart = id.indexOf('z');
                return { x: parseInt(id.substring(1, zstart)), z: parseInt(id.substring(zstart + 1)) };
            }
            function pointToHash(point) {
                return point.x + (point.z >= 0 ? '_' : '') + point.z;
            }
            function isSemiPointHash(hash) {
                return /^-?[0-9]+(\.5)?[_-][0-9]+(\.5)?$/.test(hash);
            }
            function isPointHash(hash) {
                return /^-?[0-9]+[_-][0-9]+$/.test(hash);
            }
            function hashToPoint(hash) {
                var xend = hash.indexOf('_', 1);
                var zstart = xend + 1;
                if (xend < 0) {
                    xend = hash.indexOf('-', 1);
                    zstart = xend;
                }
                return { x: parseFloat(hash.substring(0, xend)), z: parseFloat(hash.substring(zstart)) };
            }
            function getHash() {
                var centerStr = 'auto';
                var cxElem = document.getElementById('center_x');
                var czElem = document.getElementById('center_z');
                if (cxElem.value != '' && czElem.value != '') {
                    centerStr = pointToHash({ x: cxElem.valueAsNumber, z: czElem.valueAsNumber });
                }
                var correctionStr = document.forms[0]['correction'].value;
                if (correctionStr == 'custom') correctionStr = document.getElementById('correction_radius').value;
                var pointsStr = getPoints().map(pointToHash).join('/');

                var hash = '#' + centerStr + '/' + correctionStr;
                if (pointsStr != '') hash += '/' + pointsStr;

                var highStr = document.forms[0]['highlight'].value;
                if (highStr != '') hash += '/' + highStr;

                if (walkSegment != null) {
                    var dir = getWalkDirection() > 0 ? 'r' : 'l';
                    var face = getWalkFace() > 0 ? 'f' : 'b';
                    var speed = document.getElementById('speed').valueAsNumber;
                    var is3d = document.getElementById('3d-mode').checked ? '3d/' : '';
                    var mode = null;
                    switch (getWalkPlayMode()) {
                        case -1: mode = 'rev'; break;
                        case 1: mode = 'play'; break;
                        default: mode = 'paused'; break;
                    }
                    hash += '/' + dir + '/' + face + '/' + speed + '/' + is3d + mode + '/' + walkStepNo;
                }

                return hash;
            }

            function loadFromHash() {

                if (location.hash.length <= 1) {
                    refreshForm();
                    return;
                }

                var i = 0;
                var parts = location.hash.substring(1).split('/');

                if (parts[i] == 'auto') {
                    document.getElementById('center_x').value = '';
                    document.getElementById('center_z').value = '';
                } else if (isSemiPointHash(parts[i])) {
                    var centerPt = hashToPoint(parts[i]);
                    document.getElementById('center_x').valueAsNumber = centerPt.x;
                    document.getElementById('center_z').valueAsNumber = centerPt.z;
                } else {
                    refreshForm();
                    return;
                }

                i++;
                if (i >= parts.length) {
                    refreshForm();
                    return;
                }

                var correction = parseFloat(parts[i]);
                if (isNaN(correction)) {
                    var radio = document.getElementById('correction_' + parts[i]);
                    if (!radio) {
                        refreshForm();
                        return;
                    }
                    radio.checked = true;
                } else {
                    document.getElementById('correction_custom').checked = true;
                    document.getElementById('correction_radius').valueAsNumber = correction;
                }

                i++;
                if (i >= parts.length) {
                    refreshForm();
                    return;
                }

                $('#pointsList').empty();

                while (i < parts.length && isPointHash(parts[i])) {
                    addPoint();
                    var point = hashToPoint(parts[i]);
                    document.getElementById('point' + pointCounter + '_x').valueAsNumber = point.x;
                    document.getElementById('point' + pointCounter + '_z').valueAsNumber = point.z;

                    i++;
                }
                addPoint();

                if (i >= parts.length) {
                    refreshForm();
                    return;
                }

                var hradio = document.getElementById('highlight_' + parts[i]);
                if (!hradio) {
                    refreshForm();
                    return;
                }
                hradio.checked = true;

                refreshForm();

                i++;
                if (i >= parts.length) {
                    return;
                }

                var toolbar = document.getElementById('walkToolbar');

                if (parts[i] == 'r') toolbar.dir.value = 'clockwise';
                else if (parts[i] == 'l') toolbar.dir.value = 'anticlockwise';
                else return;

                i++;
                if (i >= parts.length) {
                    walkFromHash(0);
                    return;
                }

                if (parts[i] == 'f') toolbar.face.value = 'ahead';
                else if (parts[i] == 'b') toolbar.face.value = 'behind';
                else {
                    walkFromHash(0);
                    return;
                }

                i++;
                if (i >= parts.length) {
                    walkFromHash(0);
                    return;
                }

                speed = parseInt(parts[i]);
                if (speed >= 1 && speed <= 10) toolbar.speed.value = speed;
                else {
                    walkFromHash(0);
                    return;
                }

                i++;
                if (i >= parts.length) {
                    walkFromHash(0);
                    return;
                }

                toolbar['3d-mode'].checked = parts[i] == '3d';
                if (parts[i] == '3d') i++;

                if (i >= parts.length) {
                    walkFromHash(0);
                    return;
                }

                if (parts[i] == 'rev') toolbar.playmode.value = 'play-rev';
                else if (parts[i] == 'play') toolbar.playmode.value = 'play-fwd';
                else if (parts[i] == 'paused') toolbar.playmode.value = 'pause';
                else {
                    walkFromHash(0);
                    return;
                }

                i++;
                if (i >= parts.length) {
                    walkFromHash(0);
                    return;
                }

                walkFromHash(parseInt(parts[i]));
            }

            function renderingComplete() {
                // Not sure if we want to do anything here but this way we can
            }
            function pathRenderingComplete() {
                // Not sure if we want to do anything here but this way we can
            }

            function walkFromHash(stepNo) {
                var highlightFn = getCurrentHighlightFunction();
                var first = findStartSegment(getWalkDirection(), highlightFn);
                if (first == null) return;

                walkSegment = first.segment;
                walkOffset = first.offset + stepNo;
                walkStepNo = stepNo;
                walkAnimating = false;

                while (walkOffset > walkSegment.count) {
                    walkOffset -= walkSegment.count + 1;
                    walkSegment = segmentNext(walkSegment, highlightFn);
                }

                moveToWalkPoint('walk-mode');
                setHash();
                walkStep();
            }

            function setChunkShown(chunk, isShown) {
                var id = pointToId(chunk);
                console.log('Setting chunk ' + id + ' to ' + isShown);
                let elem = elemById('grid_' + id);
                if (elem != null) elem.classList.toggle('shown', isShown);
                let pathElem = elemById('path_' + id);
                if (pathElem != null) pathElem.classList.toggle('shown', isShown);
            }

            function setShownChunks(rect) {
                rect = rectClipChunks(rect);
                console.log('Setting shown chunks to ' + vecStr(rect.from) + ' - ' + vecStr(rect.to));

                if (shownChunkRect != null && rectEqual(rect, shownChunkRect)) return;

                var changeRect = shownChunkRect == null ? rect : rectUnion(shownChunkRect, rect);
                for (let chunkZ = changeRect.from.z; chunkZ <= changeRect.to.z; chunkZ++) {
                    for (let chunkX = changeRect.from.x; chunkX <= changeRect.to.x; chunkX++) { 
                        let chunk = {x: chunkX, z: chunkZ};
                        setChunkShown(chunk, rectContains(rect, chunk));
                    }
                }
                shownChunkRect = rect;
            }

            function clearShownChunks() {
                if (shownChunkRect == null) return;

                for (let chunkZ = shownChunkRect.from.z; chunkZ <= shownChunkRect.to.z; chunkZ++) {
                    for (let chunkX = shownChunkRect.from.x; chunkX <= shownChunkRect.to.x; chunkX++) {
                        setChunkShown({x: chunkX, z: chunkZ}, false);
                    }
                }
                shownChunkRect = null;
            }

            function rectClip(rect) {
                return rectIntersect(rect, {from: from, to: to});
            }
            function rectClipChunks(rect) {
                return rectIntersect(rect, {from: chunkOfPoint(from), to: chunkOfPoint(to)});
            }
            function rectUnion(a, b) {
                return {
                    from: { x: Math.min(a.from.x, b.from.x), z: Math.min(a.from.z, b.from.z) },
                    to: { x: Math.max(a.to.x, b.to.x), z: Math.max(a.to.z, b.to.z) },
                };
            }
            function rectIntersect(a, b) {
                return {
                    from: { x: Math.max(a.from.x, b.from.x), z: Math.max(a.from.z, b.from.z) },
                    to: { x: Math.min(a.to.x, b.to.x), z: Math.min(a.to.z, b.to.z) },
                };
            }
            function rectEqual(a, b) {
                return vecEqual(a.from, b.from) && vecEqual(a.to, b.to);
            }
            function rectContains(rect, point) {
                return point.x >= rect.from.x && point.x <= rect.to.x && point.z >= rect.from.z && point.z <= rect.to.z;
            }
            function chunkOfPoint(point) {
                return { x: Math.floor(point.x / 16), z: Math.floor(point.z / 16) };
            }
            function chunkRect(chunk) {
                return rectClip({
                    from: { x: chunk.x * 16, z: chunk.z * 16 },
                    to: { x: chunk.x * 16 + 15, z: chunk.z * 16 + 15 },
                });
            }
            function chunkCentre(chunk) {
                return { x: chunk.x * 16 + 7.5, z: chunk.z * 16 + 7.5 };
            }

            function* allChunks() {
                let chunkFrom = chunkOfPoint(from);
                let chunkTo = chunkOfPoint(to);
                let cols = chunkTo.x - chunkFrom.x + 1;
                let rows = chunkTo.z - chunkFrom.z + 1;

                // This approach yields the chunks in a diagonal pattern so the ones near the top left get rendered first.
                for (let line = 0; line < rows + cols - 1; line++) {
                    for (let chunk = {x: chunkFrom.x + Math.max(0, line + 1 - cols), z: Math.min(chunkFrom.z + line, chunkTo.z)};
                         chunk.x <= chunkTo.x && chunk.z >= chunkFrom.z;
                         chunk = vecAdd(chunk, {x: 1, z: -1})) {
                        yield chunk;
                    }
                }
            }

            function renderPath() {
                elemDo('grid-path-holder', elemClear());

                countPath();

                const batchSize = 128;

                let highlightFn = getCurrentHighlightFunction();
                if (highlightFn == null) return;

                let chunk = {x: null, z: null};
                let rect;
                let chunkDiv;
                let lastSegmentWasRendered = false;
                let segments = allSegments(1, highlightFn);

                // Algorithm:
                // Iterator over all segments
                // Keep track of current chunk
                // Render the part of the segment that's within the current chunk
                // If that's not the whole thing, lop it off and do the next part
                function triggerBatch() {
                    this.removeEventListener('animationstart', triggerBatch);
                    requestAnimationFrame(renderBatch);
                }
                function renderBatch() {
                    let done = false;
                    let lastStrip = null;

                    for (let i = 0; i < batchSize; i++) {
                        let next = segments.next();
                        if (next.done) {
                            done = true;
                            break;
                        }
                        let segment = next.value;

                        // If the last segment was rendered and this one's length is 1 or less, we don't need to render it.
                        if (lastSegmentWasRendered) {
                            if (segment.count <= 1) {
                                if (segment.count == 1) lastSegmentWasRendered = false;
                                continue;
                            } else {
                                segment = segmentSkip(segment, 1);
                            }
                        }

                        let end = segmentEnd(segment);
                        while (true) {
                            let newChunk = chunkOfPoint(segment.start);
                            if (!vecEqual(newChunk, chunk)) {
                                chunk = newChunk;
                                rect = chunkRect(chunk);
                                let id = 'path_' + pointToId(chunk);
                                chunkDiv = elemById(id);
                                if (chunkDiv == null) {
                                    chunkDiv = document.createElement('div')
                                    chunkDiv.setAttribute('id', id);
                                    chunkDiv.setAttribute('class', 'path-blocks-layer');
                                    if (shownChunkRect != null && rectContains(shownChunkRect, chunk)) chunkDiv.classList.add('shown');
                                    elemById('grid-path-holder').appendChild(chunkDiv);
                                }
                            }
                            let len;
                            if (segment.startIsConnect) {
                                len = 0;
                            } else if (end.x < rect.from.x) {
                                len = segment.start.x - rect.from.x;
                            } else if (end.x > rect.to.x) {
                                len = rect.to.x - segment.start.x;
                            } else if (end.z < rect.from.z) {
                                len = segment.start.z - rect.from.z;
                            } else if (end.z > rect.to.z) {
                                len = rect.to.z - segment.start.z;
                            } else if (segment.endIsConnect) {
                                len = segment.count - 1;
                            } else {
                                len = segment.count;
                            }

                            let head = segmentTruncate(segment, len);

                            // If the segment is going in a negative coordinate direction, reverse it.
                            if (head.orientation >= 2) head = segmentReverse(head);

                            // Render strip
                            lastStrip = createBlocksDiv(
                                (head.startIsConnect ? 'connect ' : 'highlight ') + (head.orientation == orientations.East ? 'across' : 'down'),
                                head.start,
                                (head.orientation == orientations.East ? head.count + 1 : null),
                                (head.orientation == orientations.East ? null : head.count + 1));
                            lastStrip.style.setProperty('animation-delay', (i / batchSize) + 's');
                            chunkDiv.appendChild(lastStrip);

                            // If we just rendered the whole thing we're done with this segment
                            if (len == segment.count) break;

                            // Otherwise move on to whatever's left
                            segment = segmentSkip(segment, len + 1);
                        }
                    }
                    //elemsDo('.progress', elemSetStyle('background-size', (currentChunks * 100 / totalChunks) + '% 100%'));
                    if (done) {
                        pathRenderingComplete();
                    } else {
                        lastStrip.addEventListener('animationstart', triggerBatch);
                    }
                }
                requestAnimationFrame(renderBatch);                    
            }

            function setHash() {
                var newHash = getHash();
                if (location.hash != newHash) history.pushState(null, '', newHash);
            }
            function setHashReplace() {
                var newHash = getHash();
                if (location.hash != newHash) history.replaceState(null, '', newHash);
            }

            function isArrayLike(obj) {
                return (
                    Array.isArray(obj) ||
                    obj instanceof NodeList ||
                    (!!obj &&
                      typeof obj === "object" &&
                      obj.hasOwnProperty("length") &&
                      typeof (obj.length) === "number" &&
                      (obj.length === 0 ||
                         (obj.length > 0 &&
                         (obj.length - 1) in item)
                      )
                    )
                );
            }

            // Quicker than typing them out in full each time
            function elemById(id) {
                return document.getElementById(id);
            }
            function elemBy(selector, parent) {
                if (parent == null) parent = document;
                return parent.querySelector(selector);
            }
            function elemsBy(selector, parent) {
                if (parent == null) parent = document;
                return parent.querySelectorAll(selector);
            }
            function elemCreate(tag, ...actions) {
                return elemDo(document.createElement(tag), ...actions);
            }

            // elem can be an ID or an element; for a selector use elemsDo even if only one
            function elemDo(elem, ...actions) {
                if (elem == null) return;
                if (typeof elem === 'string') elem = elemById(elem);
                for (var action of actions) action(elem);
                return elem;
            }

            // elems can be a selector, element or arraylike-thing of elements
            function elemsDo(elems, ...actions) {

                if (elems instanceof Element) {
                    for (var action of actions) action(elems);
                } else {

                    if (typeof elems == 'string') elems = elemsBy(elems);
                    for (var elem of elems) {
                        for (var action of actions) action(elem);
                    }
                }
            }

            function elemClear() {
                return function(elem) {
                    while (elem.firstChild) {
                        elem.removeChild(elem.firstChild);
                    }
                };
            }

            function elemRemove() {
                return function(elem) { elem.remove(); };
            }

            function elemSetClass(className, isSet) {
                if (isSet == null) isSet = true;
                classes = className.split(/\s+/);
                return function(elem) {
                    for (var cls of classes) {
                        elem.classList.toggle(cls, isSet);
                    }
                };
            }

            function elemSetAttr(attr, val) {
                // Handle boolean attributes by setting the value to the attribute name for true or removing the attribute for false.
                if (typeof val === 'boolean') val = val ? attr : null;

                if (val == null) {
                    return function(elem) { elem.removeAttribute(attr); };
                } else {
                    return function(elem) { elem.setAttribute(attr, val); };
                }
            }

            function elemSetStyle(prop, val) {
                if (val == null) {
                    return function(elem) { elem.style.removeProperty(prop); };
                } else {
                    return function(elem) { elem.style.setProperty(prop, val); };
                }
            }

            function elemSetText(text) {
                return function(elem) { elem.textContent = text; };
            }

            function elemSetHtml(html) {
                return function(elem) { elem.innerHTML = html; };
            }

            function elemSetVisible(isVisible) {
                if (isVisible == null) isVisible = true;
                return elemSetStyle('display', isVisible ? null : 'none');
            }

            function clearGrid() {
                elemsDo('.grid-layer', elemClear());
            }

            function buildCircle() {
                setHash();
                center = { x: 0, z: 0 };
                var points = getPoints();
                var cxElem = elemById('center_x');
                var czElem = elemById('center_z');
                var autoCenter = true;
                if (cxElem.value != '' && czElem.value != '') {
                    center = { x: cxElem.valueAsNumber, z: czElem.valueAsNumber };
                    autoCenter = false;
                } else if (points.length > 0) {
                    center = points[0];
                    var rguess = 0.25; // ideally would use zero, but the formulas are based around it being nonzero. A quarter of a block is necessarily smaller than any actual distance between coordinates that aren't equal to each other, so it works.
                    var rsquared = 0.0625;
                    for (var n = 1; n < points.length; n++) {
                        var pn = points[n];
                        var vn = vecSub(pn, center);
                        if (vecSquared(vn) > rsquared) {
                            var rn = vecDiv(vecMul(vn, rguess), vecMod(vn))
                            var an = 1.0;
                            for (var i = 0; i < n; i++) {
                                var di = vecAdd(vecSub(points[i], pn), rn);
                                var dsquared = vecSquared(di);
                                if (dsquared > rsquared) {
                                    var ai = 1.0 - (dsquared - rsquared) / (2.0 * (vecDot(di, rn) - rsquared));
                                    if (ai > an) an = ai;
                                }
                            }
                            center = vecSub(pn, vecMul(rn, an));
                            rguess = an * rguess;
                            rsquared = rguess * rguess;
                        }
                    }
                }

                var correction = getCorrectionRadius();
                outer = correction;
                inner = 0;

                if (points.length > 0) {
                    var first = getDistance(center, points[0]);
                    outer = first + correction;
                    inner = first - correction;
                    for (var i = 1; i < points.length; i++) {
                        var dist = getDistance(center, points[i]);
                        if (outer < dist + correction) outer = dist + correction;
                        if (inner > dist - correction) inner = dist - correction;
                    }
                }

                elemsDo('form', elemSetClass('autocenter', autoCenter));
                elemDo('center_x', elemSetAttr('title', autoCenter ? center.x : null));
                elemDo('center_z', elemSetAttr('title', autoCenter ? center.z : null));
                elemDo('centerXLabel',
                    elemSetText(center.x.toFixed(1)),
                    elemSetAttr('title', center.x));
                elemDo('centerZLabel',
                    elemSetText(center.z.toFixed(1)),
                    elemSetAttr('title', center.z));
                elemDo('innerRadiusLabel',
                    elemSetText(inner.toFixed(1)),
                    elemSetAttr('title', inner));
                elemDo('outerRadiusLabel',
                    elemSetText(outer.toFixed(1)),
                    elemSetAttr('title', outer));

                from = {
                    x: Math.floor(center.x - outer - 1.01),
                    z: Math.floor(center.z - outer - 1.01),
                };
                to = {
                    x: Math.ceil(center.x + outer + 1.01),
                    z: Math.ceil(center.z + outer + 1.01),
                };
                var gridRect = {from: from, to: to};

                clearGrid();

                elemDo('circleViewport',
                    elemSetStyle('--fromx', from.x),
                    elemSetStyle('--fromz', from.z),
                    elemSetStyle('--cols', to.x - from.x + 1),
                    elemSetStyle('--rows', to.z - from.z + 1));

                countBlocks();

                overlayCircle(center, 0.3, 'center');
                overlayCircle(center, inner, 'inner');
                overlayCircle(center, (inner + outer) / 2, 'mid');
                overlayCircle(center, outer, 'outer');
                for (var i = 0; i < points.length; i++) {
                    overlayCircle(points[i], correction, 'point');
                }

                let chunkFrom = chunkOfPoint(from);
                let chunkTo = chunkOfPoint(to);
                let totalChunks = (chunkTo.x - chunkFrom.x + 1) * (chunkTo.z - chunkFrom.z + 1);
                let currentChunks = 0;
                const batchSize = 32;
                let highlightFn = getCurrentHighlightFunction();
                let chunks = allChunks();

                function triggerBatch() {
                    this.removeEventListener('animationstart', triggerBatch);
                    requestAnimationFrame(renderBatch);
                }
                function renderBatch() {
                    let done = false;
                    let chunkDiv = null;
                    for (let i = 0; i < batchSize; i++) {
                        let next = chunks.next();
                        if (next.done) {
                            done = true;
                            break;
                        }
                        let chunk = next.value;
                        let id = pointToId(chunk);
                        let rect = chunkRect(chunk);
                        chunkDiv = renderArea('grid_' + id, rect);
                        if (shownChunkRect != null && rectContains(shownChunkRect, chunk)) chunkDiv.classList.add('shown');
                        chunkDiv.style.setProperty('animation-delay', (i / batchSize) + 's');
                        currentChunks++;
                    }
                    elemsDo('.progress', elemSetStyle('background-size', (currentChunks * 100 / totalChunks) + '% 100%'));
                    if (done) {
                        renderingComplete();
                    } else {
                        chunkDiv.addEventListener('animationstart', triggerBatch);
                    }
                }
                requestAnimationFrame(renderBatch);

                renderPath();
            }

            function countBlocks() {
                let interiorCount = 0;
                let ringCount = 0;
                for (var x = from.x; x <= to.x; x++) {
                    for (var z = from.z; z <= to.z; z++) {
                        var point = { x: x, z: z };
                        var dist = getDistance(center, point);
                        if (dist < inner) {
                            interiorCount++;
                        } else if (dist < outer) {
                            ringCount++;
                        }
                    }
                }
                setBlockCountLabel('ring', ringCount);
                setBlockCountLabel('interior', interiorCount);
            }

            function countPath() {
                var highlightFn = getCurrentHighlightFunction();

                segmentCount = 0;
                stepCount = 0;
                var pathBlocks = 0;
                var connectBlocks = 0;

                if (highlightFn != null) {
                    var minx = Math.floor(center.x);
                    var maxx = Math.ceil(center.x);
                    var minz = Math.floor(center.z);
                    var maxz = Math.ceil(center.z);

                    for (let segment of allSegments(1, highlightFn)) {
                        if (segment.start.x < minx) minx = segment.start.x;
                        if (segment.start.x > maxx) maxx = segment.start.x;
                        if (segment.start.z < minz) minz = segment.start.z;
                        if (segment.start.z > maxz) maxz = segment.start.z;

                        segmentCount++;
                        stepCount += 1 + segment.count;

                        pathBlocks += segment.count;
                        if (segment.length == 0) pathBlocks--;

                        if (segment.endIsConnect) connectBlocks++;
                    }

                    // Very small circles do funny things due to multiple overlapping, easiest to just count blocks directly in that case
                    if (maxx - minx <= 4 || maxz - minz <= 4) {
                        pathBlocks = 0;
                        connectBlocks = 0;
                        for (var x = minx; x <= maxx; x++) {
                            for (var z = minz; z <= maxz; z++) {
                                var type = highlightFn({ x: x, z: z });
                                if (type != null) pathBlocks++;
                                if (type == 'connect') connectBlocks++;
                            }
                        }
                    }
                }

                setBlockCountLabel('path', pathBlocks);
                setBlockCountLabel('highlight', pathBlocks - connectBlocks);
                setBlockCountLabel('connect', connectBlocks);

            }

            function overlayCircle(center, radius, cls) {
                let sizeClass = '';
                if (radius > sizeThresholds.huge) {
                    sizeClass = 'size-huge ';
                } else if (radius > sizeThresholds.large) {
                    sizeClass = 'size-large ';
                } else if (radius > sizeThresholds.biggish) {
                    sizeClass = 'size-biggish '
                }
                elemById('circle-holder').appendChild(
                    elemCreate('div',
                        elemSetClass('circle ' + sizeClass + cls),
                        elemSetStyle('--x', center.x),
                        elemSetStyle('--z', center.z),
                        elemSetStyle('--radius', radius))
                );
            }

            function getCurrentHighlightFunction() {
                switch (document.forms[0]['highlight'].value) {
                    case 'exterior': return exteriorHighlight;
                    case 'outside': return outsideHighlight;
                    case 'middle': return middleHighlight;
                    case 'inside': return insideHighlight;
                    case 'interior': return interiorHighlight;
                    default: return null;
                }
            }

            function getCurrentPathRadius() {
                switch (document.forms[0]['highlight'].value) {
                    case 'exterior': case 'outside': return outer;
                    case 'inside': case 'interior': return inner;
                    case 'middle': return (outer + inner) / 2;
                    default: return null;
                }
            }

            function refreshPath() {
                endWalk();
                renderPath();
            }

            function setBlockCountLabel(type, count) {
                var container = elemById(type + '-count');
                elemDo(container, elemSetVisible(count > 0));

                if (count > 0) {
                    elemDo(elemBy('.block-count', container), elemSetText(count));

                    elemDo(elemBy('.stacks', container), elemSetVisible(count >= 64));

                    if (count >= 64) {
                        var rem = count % 64;
                        var stacks = (count - rem) / 64;
                        elemDo(elemBy('.stack-count', container), elemSetText(stacks));
                        elemDo(elemBy('.rem', container), elemSetVisible(rem > 0));
                        elemDo(elemBy('.stack-rem', container), elemSetText(rem));
                    }
                }
            }

            function exteriorHighlight(point) {
                return testSurroundings(point, function (c) { return getDistance(center, c) >= outer });
            }
            function outsideHighlight(point) {
                return testSurroundings(point, function (c) { return getDistance(center, c) < outer });
            }
            function middleHighlight(point) {
                var r = (outer + inner) / 2;

                var off = getDistance(point, center) - r;
                if (off < -1 || off > 1) return null;
                if (off == 0) return 'highlight';

                var offN = r - getDistance({ x: point.x, z: point.z - 1 }, center);
                var offE = r - getDistance({ x: point.x + 1, z: point.z }, center);
                var offS = r - getDistance({ x: point.x, z: point.z + 1 }, center);
                var offW = r - getDistance({ x: point.x - 1, z: point.z }, center);
                if (off > 0) {
                    if (offN > off || offE > off || offS > off || offW > off) {
                        return 'highlight';
                    }
                } else {
                    if (offN <= off || offE <= off || offS <= off || offW <= off) {
                        return 'highlight';
                    }
                }

                var offNE = r - getDistance({ x: point.x + 1, z: point.z - 1 }, center);
                var offSE = r - getDistance({ x: point.x + 1, z: point.z + 1 }, center);
                var offSW = r - getDistance({ x: point.x - 1, z: point.z + 1 }, center);
                var offNW = r - getDistance({ x: point.x - 1, z: point.z - 1 }, center);

                if (off > 0) {
                    if (offNE > off || offSE > off || offSW > off || offNW > off) {
                        return 'connect';
                    }
                } else {
                    if (offNE <= off || offSE <= off || offSW <= off || offNW <= off) {
                        return 'connect';
                    }
                }
                return null;
            }

            function insideHighlight(point) {
                return testSurroundings(point, function (c) { return getDistance(center, c) >= inner });
            }
            function interiorHighlight(point) {
                return testSurroundings(point, function (c) { return getDistance(center, c) < inner });
            }

            // 'highlight' if criterion matches but an adjacent pixel doesn't
            // 'connect' if criterion matches but a diagonally adjacent pixel doesn't
            // null otherwise (criterion doesn't match, or all surrounding pixels do too)
            function testSurroundings(coord, criterion) {
                if (!criterion(coord)) return null;

                if (!criterion({ x: coord.x + 1, z: coord.z }) ||
                    !criterion({ x: coord.x - 1, z: coord.z }) ||
                    !criterion({ x: coord.x, z: coord.z + 1 }) ||
                    !criterion({ x: coord.x, z: coord.z - 1 })) return 'highlight';

                if (!criterion({ x: coord.x + 1, z: coord.z + 1 }) ||
                    !criterion({ x: coord.x + 1, z: coord.z - 1 }) ||
                    !criterion({ x: coord.x - 1, z: coord.z + 1 }) ||
                    !criterion({ x: coord.x - 1, z: coord.z - 1 })) return 'connect';

                return null;
            }

            var orientationNames = ['east', 'south', 'west', 'north'];
            var orientations = { East: 0, South: 1, West: 2, North: 3 };

            function orientationVec(orientation) {
                var isX = (orientation & 1) == 0;
                var sign = (orientation >= 2) ? -1 : 1;
                return {x: isX ? sign : 0, z: isX ? 0 : sign};
            }
            function orientationDesc(orientation) {
                var axis = (orientation & 1) == 0 ? 'X' : 'Z';
                var sign = (orientation >= 2) ? 'negative' : 'positive';
                return 'toward ' + sign + ' ' + axis;
            }

            // lr = -1 for left, 1 for right
            function orientationTurn(orientation, lr) {
                return (orientation + 4 + lr) % 4;
            }
            function orientationReverse(orientation) {
                return (orientation + 2) % 4;
            }
            function orientationMultiply(orientation, factor) {
                return factor < 0 ? orientationReverse(orientation) : orientation;
            }
            function getTurnName(lr) {
                return lr < 0 ? 'left' : 'right';
            }
            function cellCoords(elem) {
                return idToPoint(elem.getAttribute('id'));
            }

            // segment is {direction, start, orientation, count, startIsConnect, endIsConnect}
            function segmentPoint(segment, offset) {
                return vecAdd(segment.start, vecMul(orientationVec(segment.orientation), offset));
            }
            function segmentEnd(segment) {
                return segmentPoint(segment, segment.count);
            }
            function segmentReverse(segment) {
                return {
                    direction: -segment.direction,
                    start: segmentEnd(segment),
                    orientation: orientationReverse(segment.orientation),
                    count: segment.count,
                    startIsConnect: segment.endIsConnect,
                    endIsConnect: segment.startIsConnect
                };
            }
            function segmentSkip(segment, offset) {
                return {
                    direction: segment.direction,
                    start: segmentPoint(segment, offset),
                    orientation: segment.orientation,
                    count: segment.count - offset,
                    startIsConnect: offset == 0 ? segment.startIsConnect : offset == segment.count ? segment.endIsConnect : false,
                    endIsConnect: segment.endIsConnect,
                };
            }
            function segmentTruncate(segment, count) {
                return {
                    direction: segment.direction,
                    start: segment.start,
                    orientation: segment.orientation,
                    count: count,
                    startIsConnect: segment.startIsConnect,
                    endIsConnect: count == segment.count ? segment.endIsConnect : count == 0 ? segment.startIsConnect : false,
                };
            }

            // dir is 1 for forward(clockwise) or -1 for backward(anticlockwise)
            function getQuadrant(dir, point, orientation) {
                if ((orientation == orientations.North && (point.z == center.z || (point.z < center.z && point.x == center.x))) ||
                    (dir == -(Math.sign(point.x - center.x)) && (point.z < center.z || (point.z == center.z && orientation == (dir > 0 ? orientations.East : orientations.West)))))
                    return orientations.North;

                if ((orientation == orientations.East && (point.x == center.x || (point.x > center.x && point.z == center.z))) ||
                    (dir == -(Math.sign(point.z - center.z)) && (point.x > center.x || (point.x == center.x && orientation == (dir > 0 ? orientations.South : orientations.North)))))
                    return orientations.East;

                if ((orientation == orientations.West && (point.x == center.x || (point.x < center.x && point.z == center.z))) ||
                    (dir == Math.sign(point.z - center.z) && (point.x < center.x || (point.x == center.x && orientation == (dir > 0 ? orientations.North : orientations.South)))))
                    return orientations.West;

                if ((orientation == orientations.South && (point.z == center.z || (point.z > center.z && point.x == center.x))) ||
                    (dir == Math.sign(point.x - center.x) && (point.z > center.z || (point.z == center.z && orientation == (dir > 0 ? orientations.West : orientations.East)))))
                    return orientations.South;

                return null;
            }

            // direction is 1 for forward(clockwise) or -1 for backward(anticlockwise)
            // start = starting coordinate (at clockwise or anticlockwise end depending on direction)
            function segmentGet(direction, start, orientation, highlightFn) {
                var quadrant = getQuadrant(direction, start, orientation);

                // If orientation == quadrant then we're heading 'outish' and only need to look ahead
                // If orientation != quadrant we're heading 'innish' so we need to look to the outside, which happens to be IN quadrant direction
                var aheadVec = orientationVec(orientation);
                var outVec = null;
                if (orientation != quadrant) outVec = orientationVec(quadrant);

                var point = start;
                var count = 0;

                while (true) {
                    if (outVec != null && highlightFn(vecAdd(point, outVec)) != null) break;

                    if (highlightFn(vecAdd(point, aheadVec)) == null) break;

                    count++;
                    point = vecAdd(point, aheadVec);
                }

                return {
                    direction: direction,
                    start: start,
                    orientation: orientation,
                    count: count,
                    startIsConnect: highlightFn(start) == 'connect',
                    endIsConnect: highlightFn(point) == 'connect',
                };
            }

            function segmentEndTurn(segment) {
                var endPoint = segmentEnd(segment);
                if (endPoint.x == center.x || endPoint.z == center.z) endPoint = segment.start;
                return getQuadrant(segment.direction, endPoint, segment.orientation) == segment.orientation ? segment.direction : -segment.direction;
            }

            function segmentNext(segment, highlightFn) {
                var orientation = orientationTurn(segment.orientation, segmentEndTurn(segment));
                return segmentGet(segment.direction, segmentEnd(segment), orientation, highlightFn);
            }

            // Direction is 1 for forward(clockwise) or -1 for backward(anticlockwise)
            // returns {segment, offset}
            function findStartSegment(direction, highlightFn) {
                if (highlightFn == null) return null;

                direction = Math.sign(+direction);
                if (direction == 0) return null;

                var x = Math.floor(center.x + 0.5);
                var z = Math.ceil(center.z - 0.5);

                while (true) {
                    var point = highlightFn({ x: x, z: z });
                    var above = highlightFn({ x: x, z: z - 1 });

                    if (point != null && above == null) break; // Found the top!

                    if (z < from.z) return null; // Didn't find any viable top point
                    z--;
                }

                // Move backward to find the start of the segment
                var offset = 0;
                while (highlightFn({ x: x - direction * (offset + 1), z: z }) != null) {
                    offset++;
                }

                return {
                    segment: segmentGet(direction, { x: x - direction * offset, z: z }, direction > 0 ? orientations.East : orientations.West, highlightFn),
                    offset: offset,
                };
            }

            function* allSegments(direction, highlightFn) {

                var first = findStartSegment(1, highlightFn);

                if (first != null) {
                    yield first.segment;

                    for (var segment = segmentNext(first.segment, highlightFn);
                         !vecEqual(segment.start, first.segment.start) || segment.orientation != first.segment.orientation;
                         segment = segmentNext(segment, highlightFn)) {
                        yield segment;
                    }
                }
            }

            // segment is {direction, start, orientation, count, startIsConnect, endIsConnect}
            function segmentStr(segment) {
                return (segment.direction > 0 ? 'Clockwise ' : 'Anticlockwise ') +
                    orientationNames[segment.orientation] + ' from ' + vecStr(segment.start) +
                    ' for ' + segment.count + ' blocks [' + segment.startIsConnect + '/' + segment.endIsConnect + ']';
            }

            function segmentDirections(segment) {
                if (segment.count == 0) return 'Turn around at ' + vecStr(segment.start);

                var orientationName = orientationNames[segment.orientation];
                orientationName = orientationName.substring(0, 1).toUpperCase() + orientationName.substring(1);

                return orientationName + ' ' + segment.count + ' block' + (segment.count > 1 ? 's' : '') + ' to ' + vecStr(segmentEnd(segment));
            }

            function getFullDirections(direction, highlightFn) {
                var directions = [];
                var first = findStartSegment(direction, highlightFn);
                if (first == null) return "Can't find a valid path!";

                var segment = first.segment;

                directions.push('Start at ' + vecStr(segmentPoint(segment, first.offset)));

                if (first.offset < segment.count) {
                    directions.push('0: ' + segmentDirections(segmentSkip(segment, first.offset)));
                }

                var segNo = 1;
                while (segNo < 4 || !vecEqual(segmentEnd(segment), first.segment.start)) {
                    segment = segmentNext(segment, highlightFn);
                    directions.push(segNo + ': ' + segmentDirections(segment));
                    segNo++;
                }

                if (first.offset > 0) {
                    directions.push(segNo + ': ' + segmentDirections(segmentTruncate(first.segment, first.offset)));
                }

                return directions.join('\r\n');
            }

            function setAnimSpeed() {
                var speed = document.getElementById('speed').valueAsNumber;
                $('.viewport').removeClass('speed1 speed2 speed3 speed4 speed5 speed6 speed7 speed8 speed9 speed10').addClass('speed' + speed);
            }

            function moveToWalkPoint(animClass) {
                setAnimSpeed();
                var walkPoint = segmentPoint(walkSegment, walkOffset);
                elemsDo('.viewport', elemSetStyle('--point-x', walkPoint.x), elemSetStyle('--point-z', walkPoint.z));

                const showSize = {x: 20, z: 20};
                setShownChunks({from: chunkOfPoint(vecSub(walkPoint, showSize)), to: chunkOfPoint(vecAdd(walkPoint, showSize))});

                $('.viewport').removeClass('face-north face-south face-east face-west turn-left turn-right turn-180 move-north move-south move-east move-west');
                $('.walkpoint').removeClass('walkpoint');
                var vpElem = document.getElementById('circleViewport');
                $('.fading').removeClass('fading');
                vpElem.offsetWidth = vpElem.offsetWidth; // Force a reflow after removing all the animation classes
                if (animClass) {
                    $('.viewport').addClass(animClass);
                    if (animClass.startsWith('move-') || animClass.startsWith('turn-')) walkAnimating = true;
                }
                $('.viewport').addClass('face-' + orientationNames[orientationMultiply(walkSegment.orientation, getWalkFace())]);
                $('#x' + walkPoint.x + 'z' + walkPoint.z).addClass('walkpoint');

                if (animClass.startsWith('turn')) {
                    $('#walkFaceLabel').addClass('fading');
                } else if ((walkSegment.orientation & 1) != 0) {
                    $('#walkZLabel').addClass('fading');
                } else {
                    $('#walkXLabel').addClass('fading');
                }
                if (walkOffset == (getWalkPlayMode() > 0 ? walkSegment.count : 0)) $('#directionLabel').addClass('fading');
                setHashReplace();

                setFadeText('walkXLabel', walkPoint.x);
                setFadeText('walkZLabel', walkPoint.z);
                var orientation = orientationMultiply(walkSegment.orientation, getWalkFace());
                setFadeHtml('walkFaceLabel', '<strong>' + orientationNames[orientation] + '</strong> (' + orientationDesc(orientation) + ')');
                setFadeText('directionLabel', segmentDirections(walkOffset >= walkSegment.count ?
                    segmentNext(walkSegment, getCurrentHighlightFunction()) :
                    segmentSkip(walkSegment, walkOffset)));
            }

            function setFadeHtml(id, html) {
                var current = $('#' + id + ' .fade.current');
                $('#' + id + ' .fade.previous').html(current.html());
                current.html(html);
            }
            function setFadeText(id, text) {
                var current = $('#' + id + ' .fade.current');
                $('#' + id + ' .fade.previous').html(current.html());
                current.text(text);
            }

            function getCurrentOrientation() {
                var vp = $('.viewport');
                if (vp.hasClass('face-east')) return orientations.East;
                if (vp.hasClass('face-west')) return orientations.West;
                if (vp.hasClass('face-south')) return orientations.South;
                return orientations.North;
            }

            var walkSegment = null;
            var walkOffset = 0;
            var walkStepNo = 0;
            var walkAnimating = false;

            var segmentCount = 0;
            var stepCount = 0;

            var pendingSteps = 0;

            function startWalk() {
                var first = findStartSegment(getWalkDirection(), getCurrentHighlightFunction());
                if (first == null) return;

                walkSegment = first.segment;
                walkOffset = first.offset;
                walkStepNo = 0;
                walkAnimating = false;
                setHash();

                let w = elemBy('.viewport .window');
                w.scrollLeft = 0;
                w.scrollTop = 0;
                moveToWalkPoint('walk-mode');
                walkStep();
            }

            function endWalk() {
                walkSegment = null;
                walkAnimating = false;
                if ($('viewport').hasClass('walk-mode')) $('.viewport').addClass('end-walk');
                $('.viewport').removeClass('face-north face-south face-east face-west turn-left turn-right turn-180 move-north move-south move-east move-west walk-mode');
                $('.walkpoint').removeClass('walkpoint');
                $('.fading').removeClass('fading');
                clearShownChunks();
                setHash();
            }

            function walkStepAnimationEnd(evt) {

                if (walkSegment == null) return; // We're not walking!
                var anim = evt.originalEvent.animationName;
                if (!anim.startsWith('move') && !anim.startsWith('turn')) return;

                walkAnimating = false;
                walkStep();
            }

            function walkSingleStep(dir) {
                if (getWalkPlayMode() != 0) {
                    pendingSteps = 0;
                    document.getElementById('pause').checked = true;
                    setHash();
                }
                pendingSteps += dir;
                walkStep();
            }

            // 1 for clockwise, -1 for anti
            function getWalkDirection() {
                return document.getElementById('walkToolbar').dir.value == 'clockwise' ? 1 : -1;
            }

            // 1 for play forward, 0 for pause, -1 for play reversed
            function getWalkPlayMode() {
                switch (document.getElementById('walkToolbar').playmode.value) {
                    case 'play-fwd': return 1;
                    case 'play-rev': return -1;
                    default: return 0;
                }
            }


            // 1 for ahead, -1 for behind
            function getWalkFace() {
                return document.getElementById('walkToolbar').face.value == 'ahead' ? 1 : -1;
            }

            function getNextWalkPlayStep() {
                var mode = getWalkPlayMode();
                if (mode == 0) {
                    mode = Math.sign(pendingSteps);
                    pendingSteps -= mode;
                }
                return mode;
            }

            function triggerWalkStep() {
                setHash();
                walkStep();
            }

            function walkStep() {

                if (walkSegment == null) return;
                if (walkAnimating) return;

                if (getWalkDirection() != walkSegment.direction) {
                    walkSegment = segmentReverse(walkSegment);
                    walkOffset = walkSegment.count - walkOffset;
                    walkStepNo = stepCount - walkStepNo;
                }

                if (document.getElementById('3d-mode').checked != $('.viewport').hasClass('view3d')) {
                    $('.viewport').toggleClass('view3d');
                }

                if (getCurrentOrientation() == orientationMultiply(walkSegment.orientation, -getWalkFace())) {
                    moveToWalkPoint('turn-180');
                    return;
                }

                var mode = getNextWalkPlayStep();
                if (mode == 0) return;

                walkStepNo = (walkStepNo + stepCount + mode) % stepCount;
                walkOffset += mode;

                var anim = 'move-' + orientationNames[orientationMultiply(walkSegment.orientation, mode)];

                if (walkOffset > walkSegment.count) {
                    anim = 'turn-' + getTurnName(segmentEndTurn(walkSegment));
                    walkSegment = segmentNext(walkSegment, getCurrentHighlightFunction());
                    walkOffset = 0;
                } else if (walkOffset < 0) {
                    var revSegment = segmentReverse(walkSegment);
                    anim = 'turn-' + getTurnName(segmentEndTurn(revSegment));
                    walkSegment = segmentReverse(segmentNext(revSegment, getCurrentHighlightFunction()));
                    walkOffset = walkSegment.count;
                }

                moveToWalkPoint(anim);
            }

            function createBlocksDiv(type, point, cols, rows) {
                var blocks = document.createElement('div');
                blocks.setAttribute('class', 'blocks ' + type);
                if (point != null) {
                    blocks.style.setProperty('--x', point.x);
                    blocks.style.setProperty('--z', point.z);
                }
                if (cols != null) blocks.style.setProperty('--cols', cols);
                if (rows != null) blocks.style.setProperty('--rows', rows);
                return blocks;
            }

            function renderArea(id, rect) {
                var bg = getMajorityBlockType(rect.from, rect.to);
                var area = createBlocksDiv('chunk across ' + bg, rect.from, rect.to.x - rect.from.x + 1, rect.to.z - rect.from.z + 1);
                area.setAttribute('id', id);
                area.appendChild(createBlocksDiv('down trans'));
                for (var z = rect.from.z; z <= rect.to.z; z++) {
                    var stripType = bg;
                    var stripLen = 0;
                    var strip = null;
                    for (var x = rect.from.x; x <= rect.to.x; x++) {
                        var point = { x: x, z: z };
                        var dist = getDistance(center, point);
                        var type = 'outside';
                        if (dist < inner) {
                            type = 'inside';
                        } else if (dist < outer) {
                            type = 'ring';
                        }
                        if (type != stripType) {
                            stripType = type;
                            stripLen = 1;
                            if (type == bg) {
                                strip = null;
                            } else {
                                strip = createBlocksDiv('across ' + type, point, 1);
                                area.appendChild(strip);
                            }
                        } else if (strip != null) {
                            stripLen++;
                            strip.style.setProperty('--cols', stripLen);
                        }
                    }
                }
                elemById('grid-blocks-holder').appendChild(area);
                return area;
            }

            function circleIntegrate(r, x) {
                return (r * r * Math.acos(x / r) + x * circleIntersect(r, x)) / 2;
            }

            function circleIntersect(r, d) {
                return Math.sqrt(r * r - d * d);
            }

            function circleQuadrantRectOverlap(r, xmin, xmax, zmin, zmax) {

                // Entirely outside
                if (xmin * xmin + zmin * zmin > r * r) return 0;

                // Entirely inside
                if (xmax * zmax == 0 || xmax * xmax + zmax * zmax < r * r) return (xmax - xmin) * (zmax - zmin);

                // Find where the circle intersects the rectangle and cut off xmax and zmax at the circle boundary
                if (xmax * xmax + zmin * zmin > r * r) xmax = circleIntersect(r, zmin);
                var xtopIntersect = xmin;
                if (zmax * zmax + xmin * xmin > r * r) {
                    zmax = circleIntersect(r, xmin);
                } else {
                    xtopIntersect = circleIntersect(r, zmax);
                }

                // Integrate to get the area under the curve
                var areaUnderCurve = circleIntegrate(r, xmax) - circleIntegrate(r, xtopIntersect);

                // Add and subtract the rectangular parts
                return (xtopIntersect - xmin) * (zmax - zmin) + areaUnderCurve - zmin * (xmax - xtopIntersect);
            }

            function circleQuadrantFlippedRectOverlap(r, from, to, xsign, zsign) {
                var xfrom = Math.max(from.x * xsign, 0);
                var zfrom = Math.max(from.z * zsign, 0);
                var xto = Math.max(to.x * xsign, 0);
                var zto = Math.max(to.z * zsign, 0);
                return circleQuadrantRectOverlap(r, Math.min(xfrom, xto), Math.max(xfrom, xto), Math.min(zfrom, zto), Math.max(zfrom, zto));
            }

            function circleRectOverlap(centre, r, from, to) {
                from = vecAdd({ x: -0.5, z: -0.5 }, vecSub(from, centre));
                to = vecAdd({ x: 0.5, z: 0.5 }, vecSub(to, centre));
                return circleQuadrantFlippedRectOverlap(r, from, to, 1, 1) +
                       circleQuadrantFlippedRectOverlap(r, from, to, -1, 1) +
                       circleQuadrantFlippedRectOverlap(r, from, to, 1, -1) +
                       circleQuadrantFlippedRectOverlap(r, from, to, -1, -1);
            }

            function getMajorityBlockType(from, to) {
                var total = (to.x - from.x + 1) * (to.z - from.z + 1);
                var withinOuter = circleRectOverlap(center, outer, from, to);

                var inside = circleRectOverlap(center, inner, from, to);
                var ring = withinOuter - inside;
                var outside = total - withinOuter;

                if (inside >= ring && inside >= outside) return 'inside';
                return ring >= outside ? 'ring' : 'outside';
            }

        </script>
    </head>
    <body>
        <div class="controls">
            <form id="mainForm" onsubmit="return false">
                <input type="submit" style="display:none" id="validate">
                <template id="pointTemplate">
                    <div class="pointrow">
                        <input class="pointx" type="number" placeholder="X">
                        <input class="pointz" type="number" placeholder="Z">
                    </div>
                </template>
                <div class="column">
                    <div>
                        Center:
                        <input type="number" step="0.5" id="center_x" placeholder="X">
                        <input type="number" step="0.5" id="center_z" placeholder="Z">
                    </div>
                    <div class="radiolist">
                        <span class="radiolabel">Point Size:</span>
                        <div class="itemwrapper">
                            <div class="items">
                                <label><input type="radio" name="correction" value="point" id="correction_point">Point</label>
                                <label><input type="radio" name="correction" value="inside" id="correction_inside">Inside</label>
                                <label><input type="radio" name="correction" value="area" id="correction_area" checked>Area</label>
                                <label><input type="radio" name="correction" value="outside" id="correction_outside">Outside</label>
                                <label>
                                    <input type="radio" name="correction" value="custom" id="correction_custom">Custom
                                    <input type="number" min="0" step="any" id="correction_radius">
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="radiolist">
                        <span class="radiolabel">Path:</span>
                        <div class="itemwrapper">
                            <div class="items">
                                <label><input type="radio" name="highlight" value="" checked id="highlight_none">None</label>
                                <label><input type="radio" name="highlight" value="exterior" id="highlight_exterior">Exterior</label>
                                <label><input type="radio" name="highlight" value="outside" id="highlight_outside">Outside</label>
                                <label><input type="radio" name="highlight" value="middle" id="highlight_middle">Middle</label>
                                <label><input type="radio" name="highlight" value="inside" id="highlight_inside">Inside</label>
                                <label><input type="radio" name="highlight" value="interior" id="highlight_interior">Interior</label>
                            </div>
                        </div>
                        <button type="button" id="walk">Walk</button>
                    </div>
                    <div class="progress">
                        <span class="centerlabel">C: X<span id='centerXLabel'></span>,Z<span id='centerZLabel'></span></span>
                        R: <span id='innerRadiusLabel'></span>-<span id='outerRadiusLabel'></span>
                    </div>
                    <div id="ring-count">
                        <span class="count-label">Ring:</span>
                        <span class="block-count"></span><span class="ring-block block"></span>
                        <span class="stacks">
                            (<span class="stack-count"></span><span class="ring-block stack"></span>
                            <span class="rem"> + <span class="stack-rem"></span><span class="ring-block block"></span></span>)
                        </span>
                    </div>
                    <div id="interior-count">
                        <span class="count-label">Interior:</span>
                        <span class="block-count"></span><span class="interior-block block"></span>
                        <span class="stacks">
                            (<span class="stack-count"></span><span class="interior-block stack"></span>
                            <span class="rem"> + <span class="stack-rem"></span><span class="interior-block block"></span></span>)
                        </span>
                    </div>
                    <div id="path-count">
                        <span class="count-label">Path:</span>
                        <span class="block-count"></span><span class="path-block block"></span>
                        <span class="stacks">
                            (<span class="stack-count"></span><span class="path-block stack"></span>
                            <span class="rem"> + <span class="stack-rem"></span><span class="path-block block"></span></span>)
                        </span>
                    </div>
                    <div>
                        <span id="highlight-count">
                            <span class="block-count"></span><span class="highlight-block block"></span>
                            <span class="stacks">
                                (<span class="stack-count"></span><span class="highlight-block stack"></span>
                                <span class="rem"> + <span class="stack-rem"></span><span class="highlight-block block"></span></span>)
                            </span>
                        </span>
                        <span id="connect-count">
                            <span class="block-count"></span><span class="connect-block block"></span>
                            <span class="stacks">
                                (<span class="stack-count"></span><span class="connect-block stack"></span>
                                <span class="rem"> + <span class="stack-rem"></span><span class="connect-block block"></span></span>)
                            </span>
                        </span>
                    </div>
                </div>
                <div class="column pointscol">
                    Points:
                    <div id="pointsList"></div>
                </div>
            </form>
        </div>
        <div id="circleViewport" class="viewport">
            <div class="sky walkanim"></div>
            <div class="walk-info">
                <form class="walk-toolbar" id="walkToolbar">
                    <span class="walk-toolbar-grp">
                        <span class="tool-button trigger big" title="Reverse play">
                            <input id="play-rev" type="radio" name="playmode" value="play-rev" />
                            <label for="play-rev">&#x25c0;</label>
                        </span>
                        <span class="tool-button trigger" id="step-rev" title="Step back">&#x23ef;</span>
                        <span class="tool-button" title="Pause">
                            <input id="pause" type="radio" name="playmode" value="pause" />
                            <label for="pause">&#x23f8;</label>
                        </span>
                        <span class="tool-button trigger" id="step-fwd" title="Step forward">&#x23ef;</span>
                        <span class="tool-button trigger big" title="Play">
                            <input id="play-fwd" type="radio" name="playmode" value="play-fwd" checked />
                            <label for="play-fwd">&#x25b6;</label>
                        </span>
                    </span>
                    <span class="walk-toolbar-grp">
                        <span class="tool-button trigger" title="Clockwise">
                            <input id="dir-clockwise" type="radio" name="dir" value="clockwise" checked />
                            <label for="dir-clockwise">&#x21bb;</label>
                        </span>
                        <span class="tool-button trigger" title="Anticlockwise">
                            <input id="dir-anticlockwise" type="radio" name="dir" value="anticlockwise" />
                            <label for="dir-anticlockwise">&#x21ba;</label>
                        </span>
                    </span>
                    <span class="walk-toolbar-grp">
                        <span class="tool-button trigger" title="Face ahead">
                            <input id="face-ahead" type="radio" name="face" value="ahead" checked />
                            <label for="face-ahead">&#x21e7;</label>
                        </span>
                        <span class="tool-button trigger" title="Face behind">
                            <input id="face-behind" type="radio" name="face" value="behind" />
                            <label for="face-behind">&#x21e9;</label>
                        </span>
                    </span>
                    <span class="tool-button trigger" title="3D Mode">
                        <input id="3d-mode" type="checkbox" name="3d-mode" />
                        <label for="3d-mode">&#x23e2;</label>
                    </span>
                    <span class="tool-slider" title="Speed">
                        <input id="speed" type="range" min="1" max="10" name="speed" value="7" />
                    </span>
                    <span class="tool-button" id="exit-walk" title="Exit walk">&#x2716;</span>
                </form>
                <div class="walk-directionbar">
                    <div class="walk-direction fade-box" id="directionLabel"><span class="fade current"></span><span class="fade previous"></span></div>
                </div>
                <div class="walk-location">
                    <div class="walk-coord fade-box" id="walkXLabel"><span class="walk-label">X:</span> <strong class="fade current"></strong><strong class="fade previous"></strong></div>
                    <div class="walk-coord fade-box" id="walkZLabel"><span class="walk-label">Z:</span> <strong class="fade current"></strong><strong class="fade previous"></strong></div>
                    <div class="walk-face fade-box" id="walkFaceLabel"><span class="walk-label">Facing:</span> <span class="fade current"></span><span class="fade previous"></span></div>
                </div>
            </div>
            <div class="window">
                <div id="backtable" class="table">
                    <div class="backdrop">
                        <div id="tilttable" class="table walkanim">
                            <div id="facetable" class="table">
                                <div id="turntable" class="table walkanim">
                                    <div id="loctable" class="table">
                                        <div id="movetable" class="table walkanim">
                                            <div id="grid-area" class="grid-area">
                                                <div id="grid-blocks-holder" class="grid-layer grid-blocks-layer"></div>
                                                <div id="grid-path-holder" class="grid-layer grid-path-layer"></div>
                                                <div id="circle-holder" class="grid-layer circle-layer"></div>
                                                <div id="flash-holder" class="grid-layer flash-layer"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="crosshair-layer">
                                <div class="crosshair across"></div>
                                <div class="crosshair down"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>